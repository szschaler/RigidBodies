/*
 * generated by Xtext
 */
package uk.ac.kcl.inf.robotics.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.robotics.rigidBodies.AddExp;
import uk.ac.kcl.inf.robotics.rigidBodies.AdditiveJointType;
import uk.ac.kcl.inf.robotics.rigidBodies.AdditiveLockedJointType;
import uk.ac.kcl.inf.robotics.rigidBodies.BaseMatrix;
import uk.ac.kcl.inf.robotics.rigidBodies.BaseStiffnessExp;
import uk.ac.kcl.inf.robotics.rigidBodies.BasicJointType;
import uk.ac.kcl.inf.robotics.rigidBodies.BasicLockedJointType;
import uk.ac.kcl.inf.robotics.rigidBodies.BasicReorientExpression;
import uk.ac.kcl.inf.robotics.rigidBodies.Body;
import uk.ac.kcl.inf.robotics.rigidBodies.BodyReference;
import uk.ac.kcl.inf.robotics.rigidBodies.BodyRepetition;
import uk.ac.kcl.inf.robotics.rigidBodies.Configuration;
import uk.ac.kcl.inf.robotics.rigidBodies.ConfigurationDef;
import uk.ac.kcl.inf.robotics.rigidBodies.ConstantOrFunctionCallExp;
import uk.ac.kcl.inf.robotics.rigidBodies.Constraint;
import uk.ac.kcl.inf.robotics.rigidBodies.ConstraintClause;
import uk.ac.kcl.inf.robotics.rigidBodies.ControlStatement;
import uk.ac.kcl.inf.robotics.rigidBodies.Environment;
import uk.ac.kcl.inf.robotics.rigidBodies.ExternalLoad;
import uk.ac.kcl.inf.robotics.rigidBodies.Joint;
import uk.ac.kcl.inf.robotics.rigidBodies.JointConstraint;
import uk.ac.kcl.inf.robotics.rigidBodies.JointType;
import uk.ac.kcl.inf.robotics.rigidBodies.JointTypeReference;
import uk.ac.kcl.inf.robotics.rigidBodies.KeepUnlockedJointType;
import uk.ac.kcl.inf.robotics.rigidBodies.LockDoFStatement;
import uk.ac.kcl.inf.robotics.rigidBodies.LockJointStatement;
import uk.ac.kcl.inf.robotics.rigidBodies.LockedPlanar;
import uk.ac.kcl.inf.robotics.rigidBodies.LockedRevolute;
import uk.ac.kcl.inf.robotics.rigidBodies.Mass;
import uk.ac.kcl.inf.robotics.rigidBodies.MatrixRef;
import uk.ac.kcl.inf.robotics.rigidBodies.Model;
import uk.ac.kcl.inf.robotics.rigidBodies.MultExp;
import uk.ac.kcl.inf.robotics.rigidBodies.NumberLiteral;
import uk.ac.kcl.inf.robotics.rigidBodies.ParenthesisedExp;
import uk.ac.kcl.inf.robotics.rigidBodies.Planar;
import uk.ac.kcl.inf.robotics.rigidBodies.RelativeTransformation;
import uk.ac.kcl.inf.robotics.rigidBodies.ReorientRef;
import uk.ac.kcl.inf.robotics.rigidBodies.Reorientation;
import uk.ac.kcl.inf.robotics.rigidBodies.Revolute;
import uk.ac.kcl.inf.robotics.rigidBodies.RigidBodiesPackage;
import uk.ac.kcl.inf.robotics.rigidBodies.StiffnessRef;
import uk.ac.kcl.inf.robotics.rigidBodies.SystemInstantiation;
import uk.ac.kcl.inf.robotics.services.RigidBodiesGrammarAccess;

@SuppressWarnings("all")
public class RigidBodiesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RigidBodiesGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RigidBodiesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RigidBodiesPackage.ADD_EXP:
				sequence_AddExp(context, (AddExp) semanticObject); 
				return; 
			case RigidBodiesPackage.ADDITIVE_JOINT_TYPE:
				sequence_AdditiveJointType(context, (AdditiveJointType) semanticObject); 
				return; 
			case RigidBodiesPackage.ADDITIVE_LOCKED_JOINT_TYPE:
				sequence_AdditiveLockedJointType(context, (AdditiveLockedJointType) semanticObject); 
				return; 
			case RigidBodiesPackage.BASE_MATRIX:
				sequence_BaseMatrix(context, (BaseMatrix) semanticObject); 
				return; 
			case RigidBodiesPackage.BASE_STIFFNESS_EXP:
				sequence_BaseStiffnessExp(context, (BaseStiffnessExp) semanticObject); 
				return; 
			case RigidBodiesPackage.BASIC_JOINT_TYPE:
				sequence_BasicJointType(context, (BasicJointType) semanticObject); 
				return; 
			case RigidBodiesPackage.BASIC_LOCKED_JOINT_TYPE:
				sequence_BasicLockedJointType(context, (BasicLockedJointType) semanticObject); 
				return; 
			case RigidBodiesPackage.BASIC_REORIENT_EXPRESSION:
				sequence_BasicReorientExpression(context, (BasicReorientExpression) semanticObject); 
				return; 
			case RigidBodiesPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case RigidBodiesPackage.BODY_REFERENCE:
				sequence_BodyReference(context, (BodyReference) semanticObject); 
				return; 
			case RigidBodiesPackage.BODY_REPETITION:
				sequence_BodyRepetition(context, (BodyRepetition) semanticObject); 
				return; 
			case RigidBodiesPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case RigidBodiesPackage.CONFIGURATION_DEF:
				sequence_ConfigurationDef(context, (ConfigurationDef) semanticObject); 
				return; 
			case RigidBodiesPackage.CONSTANT_OR_FUNCTION_CALL_EXP:
				sequence_ConstantOrFunctionCallExp(context, (ConstantOrFunctionCallExp) semanticObject); 
				return; 
			case RigidBodiesPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case RigidBodiesPackage.CONSTRAINT_CLAUSE:
				sequence_ConstraintClause(context, (ConstraintClause) semanticObject); 
				return; 
			case RigidBodiesPackage.CONTROL_STATEMENT:
				sequence_ControlStatement(context, (ControlStatement) semanticObject); 
				return; 
			case RigidBodiesPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case RigidBodiesPackage.EXTERNAL_LOAD:
				sequence_ExternalLoad(context, (ExternalLoad) semanticObject); 
				return; 
			case RigidBodiesPackage.JOINT:
				sequence_Joint(context, (Joint) semanticObject); 
				return; 
			case RigidBodiesPackage.JOINT_CONSTRAINT:
				sequence_JointConstraint(context, (JointConstraint) semanticObject); 
				return; 
			case RigidBodiesPackage.JOINT_TYPE:
				sequence_JointType(context, (JointType) semanticObject); 
				return; 
			case RigidBodiesPackage.JOINT_TYPE_REFERENCE:
				sequence_JointTypeReference(context, (JointTypeReference) semanticObject); 
				return; 
			case RigidBodiesPackage.KEEP_UNLOCKED_JOINT_TYPE:
				sequence_KeepUnlockedJointType(context, (KeepUnlockedJointType) semanticObject); 
				return; 
			case RigidBodiesPackage.LOCK_DO_FSTATEMENT:
				sequence_LockDoFStatement(context, (LockDoFStatement) semanticObject); 
				return; 
			case RigidBodiesPackage.LOCK_JOINT_STATEMENT:
				sequence_LockJointStatement(context, (LockJointStatement) semanticObject); 
				return; 
			case RigidBodiesPackage.LOCKED_PLANAR:
				sequence_LockedPlanar(context, (LockedPlanar) semanticObject); 
				return; 
			case RigidBodiesPackage.LOCKED_REVOLUTE:
				sequence_LockedRevolute(context, (LockedRevolute) semanticObject); 
				return; 
			case RigidBodiesPackage.MASS:
				sequence_Mass(context, (Mass) semanticObject); 
				return; 
			case RigidBodiesPackage.MATRIX_REF:
				sequence_MatrixRef(context, (MatrixRef) semanticObject); 
				return; 
			case RigidBodiesPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RigidBodiesPackage.MULT_EXP:
				sequence_MultExp(context, (MultExp) semanticObject); 
				return; 
			case RigidBodiesPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case RigidBodiesPackage.PARENTHESISED_EXP:
				sequence_ParenthesisedExp(context, (ParenthesisedExp) semanticObject); 
				return; 
			case RigidBodiesPackage.PLANAR:
				sequence_Planar(context, (Planar) semanticObject); 
				return; 
			case RigidBodiesPackage.RELATIVE_TRANSFORMATION:
				sequence_RelativeTransformation(context, (RelativeTransformation) semanticObject); 
				return; 
			case RigidBodiesPackage.REORIENT_REF:
				sequence_ReorientRef(context, (ReorientRef) semanticObject); 
				return; 
			case RigidBodiesPackage.REORIENTATION:
				sequence_Reorientation(context, (Reorientation) semanticObject); 
				return; 
			case RigidBodiesPackage.REVOLUTE:
				sequence_Revolute(context, (Revolute) semanticObject); 
				return; 
			case RigidBodiesPackage.STIFFNESS_REF:
				sequence_StiffnessRef(context, (StiffnessRef) semanticObject); 
				return; 
			case RigidBodiesPackage.SYSTEM:
				sequence_System(context, (uk.ac.kcl.inf.robotics.rigidBodies.System) semanticObject); 
				return; 
			case RigidBodiesPackage.SYSTEM_INSTANTIATION:
				sequence_SystemInstantiation(context, (SystemInstantiation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AddExp returns AddExp
	 *     AddExp.AddExp_1_0 returns AddExp
	 *
	 * Constraint:
	 *     (left=AddExp_AddExp_1_0 (op+='+' | op+='-') right+=MultExp)
	 */
	protected void sequence_AddExp(ISerializationContext context, AddExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveJointType returns AdditiveJointType
	 *     AdditiveJointType.AdditiveJointType_1_1 returns AdditiveJointType
	 *
	 * Constraint:
	 *     (left=AdditiveJointType_AdditiveJointType_1_1 right+=PrimaryJointType)
	 */
	protected void sequence_AdditiveJointType(ISerializationContext context, AdditiveJointType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveLockedJointType returns AdditiveLockedJointType
	 *     AdditiveLockedJointType.AdditiveLockedJointType_1_1 returns AdditiveLockedJointType
	 *
	 * Constraint:
	 *     (left=AdditiveLockedJointType_AdditiveLockedJointType_1_1 right+=PrimaryLockedJointType)
	 */
	protected void sequence_AdditiveLockedJointType(ISerializationContext context, AdditiveLockedJointType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialDefinition returns BaseMatrix
	 *     Matrix returns BaseMatrix
	 *     BaseMatrix returns BaseMatrix
	 *
	 * Constraint:
	 *     (name=ID? values+=AddExp values+=AddExp*)
	 */
	protected void sequence_BaseMatrix(ISerializationContext context, BaseMatrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialDefinition returns BaseStiffnessExp
	 *     StiffnessExp returns BaseStiffnessExp
	 *     BaseStiffnessExp returns BaseStiffnessExp
	 *
	 * Constraint:
	 *     (name=ID? springCoeff=AddExp springInit=AddExp dampViscous=AddExp dampCoulomb=AddExp)
	 */
	protected void sequence_BaseStiffnessExp(ISerializationContext context, BaseStiffnessExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveJointType returns BasicJointType
	 *     AdditiveJointType.AdditiveJointType_1_1 returns BasicJointType
	 *     PrimaryJointType returns BasicJointType
	 *     BasicJointType returns BasicJointType
	 *
	 * Constraint:
	 *     (type=JointMovement stiffness=StiffnessExp)
	 */
	protected void sequence_BasicJointType(ISerializationContext context, BasicJointType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.BASIC_JOINT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.BASIC_JOINT_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.BASIC_JOINT_TYPE__STIFFNESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.BASIC_JOINT_TYPE__STIFFNESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicJointTypeAccess().getTypeJointMovementParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getBasicJointTypeAccess().getStiffnessStiffnessExpParserRuleCall_2_0(), semanticObject.getStiffness());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveLockedJointType returns BasicLockedJointType
	 *     AdditiveLockedJointType.AdditiveLockedJointType_1_1 returns BasicLockedJointType
	 *     PrimaryLockedJointType returns BasicLockedJointType
	 *     BasicLockedJointType returns BasicLockedJointType
	 *
	 * Constraint:
	 *     type=LockedJointMovement
	 */
	protected void sequence_BasicLockedJointType(ISerializationContext context, BasicLockedJointType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.BASIC_LOCKED_JOINT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.BASIC_LOCKED_JOINT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicLockedJointTypeAccess().getTypeLockedJointMovementParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReorientExpression returns BasicReorientExpression
	 *     BasicReorientExpression returns BasicReorientExpression
	 *
	 * Constraint:
	 *     (axis+=AXIS value+=AddExp (axis+=AXIS value+=AddExp)*)?
	 */
	protected void sequence_BasicReorientExpression(ISerializationContext context, BasicReorientExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyReference returns BodyReference
	 *
	 * Constraint:
	 *     (base?='base' | new?='new' | (last?='last' ref=[Body|ID]?) | (ref=[Body|ID] idx=INT?))
	 */
	protected void sequence_BodyReference(ISerializationContext context, BodyReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SystemElement returns BodyRepetition
	 *     BodyRepetition returns BodyRepetition
	 *
	 * Constraint:
	 *     (number=INT body=[Body|ID] (connectionExp+=Connective | connectionExp+=JointConstraint)+)
	 */
	protected void sequence_BodyRepetition(ISerializationContext context, BodyRepetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SystemElement returns Body
	 *     Body returns Body
	 *
	 * Constraint:
	 *     (name=ID mass=Mass)
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.BODY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.BODY__NAME));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.BODY__MASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.BODY__MASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBodyAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBodyAccess().getMassMassParserRuleCall_3_0(), semanticObject.getMass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationDef returns ConfigurationDef
	 *
	 * Constraint:
	 *     (instances+=SystemInstantiation+ configs+=Configuration+)
	 */
	protected void sequence_ConfigurationDef(ISerializationContext context, ConfigurationDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (name=ID statements+=ConfigurationStatement*)
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddExp returns ConstantOrFunctionCallExp
	 *     AddExp.AddExp_1_0 returns ConstantOrFunctionCallExp
	 *     MultExp returns ConstantOrFunctionCallExp
	 *     MultExp.MultExp_1_0 returns ConstantOrFunctionCallExp
	 *     Primary returns ConstantOrFunctionCallExp
	 *     ConstantOrFunctionCallExp returns ConstantOrFunctionCallExp
	 *
	 * Constraint:
	 *     ((label=ID | label='x' | label='y' | label='z') (param+=AddExp param+=AddExp*)?)
	 */
	protected void sequence_ConstantOrFunctionCallExp(ISerializationContext context, ConstantOrFunctionCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintClause returns ConstraintClause
	 *
	 * Constraint:
	 *     (lhs=AddExp (op='=' | op='>' | op='<') rhs=AddExp)
	 */
	protected void sequence_ConstraintClause(ISerializationContext context, ConstraintClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SystemElement returns Constraint
	 *     Connective returns Constraint
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=ConstraintType 
	 *         body1=BodyReference 
	 *         relTrans1=RelativeTransformation 
	 *         body2=BodyReference 
	 *         relTrans2=RelativeTransformation
	 *     )
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__NAME));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__TYPE));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__BODY1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__BODY1));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__REL_TRANS1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__REL_TRANS1));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__BODY2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__BODY2));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__REL_TRANS2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONSTRAINT__REL_TRANS2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstraintAccess().getTypeConstraintTypeEnumRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConstraintAccess().getBody1BodyReferenceParserRuleCall_5_0(), semanticObject.getBody1());
		feeder.accept(grammarAccess.getConstraintAccess().getRelTrans1RelativeTransformationParserRuleCall_6_0(), semanticObject.getRelTrans1());
		feeder.accept(grammarAccess.getConstraintAccess().getBody2BodyReferenceParserRuleCall_8_0(), semanticObject.getBody2());
		feeder.accept(grammarAccess.getConstraintAccess().getRelTrans2RelativeTransformationParserRuleCall_9_0(), semanticObject.getRelTrans2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationStatement returns ControlStatement
	 *     ControlStatement returns ControlStatement
	 *
	 * Constraint:
	 *     (
	 *         system=[SystemInstantiation|ID] 
	 *         bodyref=BodyReference 
	 *         relative_transform=RelativeTransformation 
	 *         constraints+=ConstraintClause 
	 *         constraints+=ConstraintClause* 
	 *         P=AddExp? 
	 *         I=AddExp? 
	 *         D=AddExp?
	 *     )
	 */
	protected void sequence_ControlStatement(ISerializationContext context, ControlStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     gravity=Matrix
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.ENVIRONMENT__GRAVITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.ENVIRONMENT__GRAVITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironmentAccess().getGravityMatrixParserRuleCall_3_0(), semanticObject.getGravity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemElement returns ExternalLoad
	 *     Connective returns ExternalLoad
	 *     ExternalLoad returns ExternalLoad
	 *
	 * Constraint:
	 *     (name=ID type=LoadType body1=BodyReference position=Matrix)
	 */
	protected void sequence_ExternalLoad(ISerializationContext context, ExternalLoad semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__NAME));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.EXTERNAL_LOAD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.EXTERNAL_LOAD__TYPE));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__BODY1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONNECTIVE__BODY1));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.EXTERNAL_LOAD__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.EXTERNAL_LOAD__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalLoadAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternalLoadAccess().getTypeLoadTypeEnumRuleCall_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getExternalLoadAccess().getBody1BodyReferenceParserRuleCall_6_0(), semanticObject.getBody1());
		feeder.accept(grammarAccess.getExternalLoadAccess().getPositionMatrixParserRuleCall_11_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemElement returns JointConstraint
	 *     JointConstraint returns JointConstraint
	 *
	 * Constraint:
	 *     (name=ID joint1=[Joint|ID] joint2=[Joint|ID])
	 */
	protected void sequence_JointConstraint(ISerializationContext context, JointConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT_CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT_CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT_CONSTRAINT__JOINT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT_CONSTRAINT__JOINT1));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT_CONSTRAINT__JOINT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT_CONSTRAINT__JOINT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJointConstraintAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getJointConstraintAccess().getJoint1JointIDTerminalRuleCall_3_0_1(), semanticObject.getJoint1());
		feeder.accept(grammarAccess.getJointConstraintAccess().getJoint2JointIDTerminalRuleCall_6_0_1(), semanticObject.getJoint2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveJointType returns JointTypeReference
	 *     AdditiveJointType.AdditiveJointType_1_1 returns JointTypeReference
	 *     PrimaryJointType returns JointTypeReference
	 *     JointTypeReference returns JointTypeReference
	 *
	 * Constraint:
	 *     ref=[JointType|ID]
	 */
	protected void sequence_JointTypeReference(ISerializationContext context, JointTypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT_TYPE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT_TYPE_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJointTypeReferenceAccess().getRefJointTypeIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitialDefinition returns JointType
	 *     JointType returns JointType
	 *
	 * Constraint:
	 *     (name=ID? exp=AdditiveJointType)
	 */
	protected void sequence_JointType(ISerializationContext context, JointType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SystemElement returns Joint
	 *     Connective returns Joint
	 *     Joint returns Joint
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=JointType 
	 *         isStart?='start'? 
	 *         body1=BodyReference 
	 *         relTrans1=RelativeTransformation 
	 *         body2=BodyReference
	 *     )
	 */
	protected void sequence_Joint(ISerializationContext context, Joint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveLockedJointType returns KeepUnlockedJointType
	 *     AdditiveLockedJointType.AdditiveLockedJointType_1_1 returns KeepUnlockedJointType
	 *     PrimaryLockedJointType returns KeepUnlockedJointType
	 *     KeepUnlockedJointType returns KeepUnlockedJointType
	 *
	 * Constraint:
	 *     {KeepUnlockedJointType}
	 */
	protected void sequence_KeepUnlockedJointType(ISerializationContext context, KeepUnlockedJointType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationStatement returns LockDoFStatement
	 *     LockDoFStatement returns LockDoFStatement
	 *
	 * Constraint:
	 *     (system=[SystemInstantiation|ID] joint=[Joint|ID] lockedType=AdditiveLockedJointType)
	 */
	protected void sequence_LockDoFStatement(ISerializationContext context, LockDoFStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONFIGURATION_STATEMENT__SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONFIGURATION_STATEMENT__SYSTEM));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCK_DO_FSTATEMENT__JOINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCK_DO_FSTATEMENT__JOINT));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCK_DO_FSTATEMENT__LOCKED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCK_DO_FSTATEMENT__LOCKED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLockDoFStatementAccess().getSystemSystemInstantiationIDTerminalRuleCall_1_0_1(), semanticObject.getSystem());
		feeder.accept(grammarAccess.getLockDoFStatementAccess().getJointJointIDTerminalRuleCall_3_0_1(), semanticObject.getJoint());
		feeder.accept(grammarAccess.getLockDoFStatementAccess().getLockedTypeAdditiveLockedJointTypeParserRuleCall_5_0(), semanticObject.getLockedType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationStatement returns LockJointStatement
	 *     LockJointStatement returns LockJointStatement
	 *
	 * Constraint:
	 *     (system=[SystemInstantiation|ID] joint=[Joint|ID] rotation=Matrix translation=Matrix)
	 */
	protected void sequence_LockJointStatement(ISerializationContext context, LockJointStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.CONFIGURATION_STATEMENT__SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.CONFIGURATION_STATEMENT__SYSTEM));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCK_JOINT_STATEMENT__JOINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCK_JOINT_STATEMENT__JOINT));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCK_JOINT_STATEMENT__ROTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCK_JOINT_STATEMENT__ROTATION));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCK_JOINT_STATEMENT__TRANSLATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCK_JOINT_STATEMENT__TRANSLATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLockJointStatementAccess().getSystemSystemInstantiationIDTerminalRuleCall_1_0_1(), semanticObject.getSystem());
		feeder.accept(grammarAccess.getLockJointStatementAccess().getJointJointIDTerminalRuleCall_3_0_1(), semanticObject.getJoint());
		feeder.accept(grammarAccess.getLockJointStatementAccess().getRotationMatrixParserRuleCall_6_0(), semanticObject.getRotation());
		feeder.accept(grammarAccess.getLockJointStatementAccess().getTranslationMatrixParserRuleCall_8_0(), semanticObject.getTranslation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LockedJointMovement returns LockedPlanar
	 *     LockedPlanar returns LockedPlanar
	 *
	 * Constraint:
	 *     (axis=AXIS exp=AddExp)
	 */
	protected void sequence_LockedPlanar(ISerializationContext context, LockedPlanar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__AXIS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__AXIS));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLockedPlanarAccess().getAxisAXISEnumRuleCall_1_0(), semanticObject.getAxis());
		feeder.accept(grammarAccess.getLockedPlanarAccess().getExpAddExpParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LockedJointMovement returns LockedRevolute
	 *     LockedRevolute returns LockedRevolute
	 *
	 * Constraint:
	 *     (axis=AXIS exp=AddExp)
	 */
	protected void sequence_LockedRevolute(ISerializationContext context, LockedRevolute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__AXIS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__AXIS));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.LOCKED_JOINT_MOVEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLockedRevoluteAccess().getAxisAXISEnumRuleCall_1_0(), semanticObject.getAxis());
		feeder.accept(grammarAccess.getLockedRevoluteAccess().getExpAddExpParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mass returns Mass
	 *
	 * Constraint:
	 *     (value=AddExp position=Matrix inertia=Matrix)
	 */
	protected void sequence_Mass(ISerializationContext context, Mass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.MASS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.MASS__VALUE));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.MASS__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.MASS__POSITION));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.MASS__INERTIA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.MASS__INERTIA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMassAccess().getValueAddExpParserRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getMassAccess().getPositionMatrixParserRuleCall_5_0(), semanticObject.getPosition());
		feeder.accept(grammarAccess.getMassAccess().getInertiaMatrixParserRuleCall_7_0(), semanticObject.getInertia());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Matrix returns MatrixRef
	 *     MatrixRef returns MatrixRef
	 *
	 * Constraint:
	 *     matrix=[BaseMatrix|ID]
	 */
	protected void sequence_MatrixRef(ISerializationContext context, MatrixRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.MATRIX_REF__MATRIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.MATRIX_REF__MATRIX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatrixRefAccess().getMatrixBaseMatrixIDTerminalRuleCall_0_1(), semanticObject.getMatrix());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (defs+=InitialDefinition* world=Environment bodies+=System+ configuration=ConfigurationDef)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddExp returns MultExp
	 *     AddExp.AddExp_1_0 returns MultExp
	 *     MultExp returns MultExp
	 *     MultExp.MultExp_1_0 returns MultExp
	 *
	 * Constraint:
	 *     (left=MultExp_MultExp_1_0 (op+='*' | op+='/') right+=Primary)
	 */
	protected void sequence_MultExp(ISerializationContext context, MultExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddExp returns NumberLiteral
	 *     AddExp.AddExp_1_0 returns NumberLiteral
	 *     MultExp returns NumberLiteral
	 *     MultExp.MultExp_1_0 returns NumberLiteral
	 *     Primary returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     (neg?='-'? value=REAL)
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddExp returns ParenthesisedExp
	 *     AddExp.AddExp_1_0 returns ParenthesisedExp
	 *     MultExp returns ParenthesisedExp
	 *     MultExp.MultExp_1_0 returns ParenthesisedExp
	 *     Primary returns ParenthesisedExp
	 *     ParenthesisedExp returns ParenthesisedExp
	 *
	 * Constraint:
	 *     exp=AddExp
	 */
	protected void sequence_ParenthesisedExp(ISerializationContext context, ParenthesisedExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.PARENTHESISED_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.PARENTHESISED_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesisedExpAccess().getExpAddExpParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JointMovement returns Planar
	 *     Planar returns Planar
	 *
	 * Constraint:
	 *     axis=AXIS
	 */
	protected void sequence_Planar(ISerializationContext context, Planar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT_MOVEMENT__AXIS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT_MOVEMENT__AXIS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlanarAccess().getAxisAXISEnumRuleCall_1_0(), semanticObject.getAxis());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelativeTransformation returns RelativeTransformation
	 *
	 * Constraint:
	 *     (position=Matrix reorient=Reorientation)
	 */
	protected void sequence_RelativeTransformation(ISerializationContext context, RelativeTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.RELATIVE_TRANSFORMATION__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.RELATIVE_TRANSFORMATION__POSITION));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.RELATIVE_TRANSFORMATION__REORIENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.RELATIVE_TRANSFORMATION__REORIENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeTransformationAccess().getPositionMatrixParserRuleCall_4_0(), semanticObject.getPosition());
		feeder.accept(grammarAccess.getRelativeTransformationAccess().getReorientReorientationParserRuleCall_6_0(), semanticObject.getReorient());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReorientExpression returns ReorientRef
	 *     ReorientRef returns ReorientRef
	 *
	 * Constraint:
	 *     ref=[Reorientation|ID]
	 */
	protected void sequence_ReorientRef(ISerializationContext context, ReorientRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.REORIENT_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.REORIENT_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReorientRefAccess().getRefReorientationIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Reorientation returns Reorientation
	 *
	 * Constraint:
	 *     (name=ID? exp=ReorientExpression)
	 */
	protected void sequence_Reorientation(ISerializationContext context, Reorientation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JointMovement returns Revolute
	 *     Revolute returns Revolute
	 *
	 * Constraint:
	 *     axis=AXIS
	 */
	protected void sequence_Revolute(ISerializationContext context, Revolute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT_MOVEMENT__AXIS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT_MOVEMENT__AXIS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRevoluteAccess().getAxisAXISEnumRuleCall_1_0(), semanticObject.getAxis());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StiffnessExp returns StiffnessRef
	 *     StiffnessRef returns StiffnessRef
	 *
	 * Constraint:
	 *     ref=[BaseStiffnessExp|ID]
	 */
	protected void sequence_StiffnessRef(ISerializationContext context, StiffnessRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.STIFFNESS_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.STIFFNESS_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStiffnessRefAccess().getRefBaseStiffnessExpIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemInstantiation returns SystemInstantiation
	 *
	 * Constraint:
	 *     (system=[System|ID] name=ID)
	 */
	protected void sequence_SystemInstantiation(ISerializationContext context, SystemInstantiation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.SYSTEM_INSTANTIATION__SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.SYSTEM_INSTANTIATION__SYSTEM));
			if (transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.SYSTEM_INSTANTIATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.SYSTEM_INSTANTIATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemInstantiationAccess().getSystemSystemIDTerminalRuleCall_1_0_1(), semanticObject.getSystem());
		feeder.accept(grammarAccess.getSystemInstantiationAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (name=ID elements+=SystemElement+)
	 */
	protected void sequence_System(ISerializationContext context, uk.ac.kcl.inf.robotics.rigidBodies.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
