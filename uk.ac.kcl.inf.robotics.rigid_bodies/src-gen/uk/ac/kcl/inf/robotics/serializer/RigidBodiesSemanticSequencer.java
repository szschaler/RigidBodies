/*
 * generated by Xtext
 */
package uk.ac.kcl.inf.robotics.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.robotics.rigidBodies.ColocationConstraint;
import uk.ac.kcl.inf.robotics.rigidBodies.Joint;
import uk.ac.kcl.inf.robotics.rigidBodies.Mass;
import uk.ac.kcl.inf.robotics.rigidBodies.Model;
import uk.ac.kcl.inf.robotics.rigidBodies.RigidBodiesPackage;
import uk.ac.kcl.inf.robotics.rigidBodies.RigidBody;
import uk.ac.kcl.inf.robotics.rigidBodies.Transformation;
import uk.ac.kcl.inf.robotics.services.RigidBodiesGrammarAccess;

@SuppressWarnings("all")
public class RigidBodiesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RigidBodiesGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == RigidBodiesPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case RigidBodiesPackage.COLOCATION_CONSTRAINT:
				sequence_ColocationConstraint(context, (ColocationConstraint) semanticObject); 
				return; 
			case RigidBodiesPackage.JOINT:
				sequence_Joint(context, (Joint) semanticObject); 
				return; 
			case RigidBodiesPackage.MASS:
				sequence_Mass(context, (Mass) semanticObject); 
				return; 
			case RigidBodiesPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RigidBodiesPackage.RIGID_BODY:
				sequence_RigidBody(context, (RigidBody) semanticObject); 
				return; 
			case RigidBodiesPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (joint1=[Joint|ID] joint2=[Joint|ID])
	 */
	protected void sequence_ColocationConstraint(EObject context, ColocationConstraint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.COLOCATION_CONSTRAINT__JOINT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.COLOCATION_CONSTRAINT__JOINT1));
			if(transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.COLOCATION_CONSTRAINT__JOINT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.COLOCATION_CONSTRAINT__JOINT2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getColocationConstraintAccess().getJoint1JointIDTerminalRuleCall_1_0_1(), semanticObject.getJoint1());
		feeder.accept(grammarAccess.getColocationConstraintAccess().getJoint2JointIDTerminalRuleCall_3_0_1(), semanticObject.getJoint2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Joint(EObject context, Joint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.JOINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.JOINT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getJointAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=REAL transformations+=Transformation+)
	 */
	protected void sequence_Mass(EObject context, Mass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     rigidBodies+=RigidBody+
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID joints+=Joint+ masses+=Mass+ constraints+=Constraint*)
	 */
	protected void sequence_RigidBody(EObject context, RigidBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     joint=[Joint|ID]
	 */
	protected void sequence_Transformation(EObject context, Transformation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RigidBodiesPackage.Literals.TRANSFORMATION__JOINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RigidBodiesPackage.Literals.TRANSFORMATION__JOINT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTransformationAccess().getJointJointIDTerminalRuleCall_3_0_1(), semanticObject.getJoint());
		feeder.finish();
	}
}
