/**
 * generated by Xtext
 */
package uk.ac.kcl.inf.robotics.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import uk.ac.kcl.inf.robotics.rigidBodies.Body;
import uk.ac.kcl.inf.robotics.rigidBodies.BodyReference;
import uk.ac.kcl.inf.robotics.rigidBodies.BodyRepetition;
import uk.ac.kcl.inf.robotics.rigidBodies.Joint;
import uk.ac.kcl.inf.robotics.rigidBodies.Model;
import uk.ac.kcl.inf.robotics.rigidBodies.RigidBodiesPackage;
import uk.ac.kcl.inf.robotics.rigidBodies.SystemElement;
import uk.ac.kcl.inf.robotics.validation.AbstractRigidBodiesValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class RigidBodiesValidator extends AbstractRigidBodiesValidator {
  public final static String TOO_MANY_START_JOINTS = "tooManyStartJoints";
  
  @Check
  public void checkOnlyOneStartJoint(final uk.ac.kcl.inf.robotics.rigidBodies.System s) {
    EList<SystemElement> _elements = s.getElements();
    Iterable<Joint> _filter = Iterables.<Joint>filter(_elements, Joint.class);
    final Function1<Joint, Boolean> _function = new Function1<Joint, Boolean>() {
      @Override
      public Boolean apply(final Joint j) {
        return Boolean.valueOf(j.isIsStart());
      }
    };
    Iterable<Joint> startJoints = IterableExtensions.<Joint>filter(_filter, _function);
    int _size = IterableExtensions.size(startJoints);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final Consumer<Joint> _function_1 = new Consumer<Joint>() {
        @Override
        public void accept(final Joint j) {
          RigidBodiesValidator.this.warning("There can only be one start joint for each system", j, 
            RigidBodiesPackage.Literals.JOINT__IS_START, ValidationMessageAcceptor.INSIGNIFICANT_INDEX, 
            RigidBodiesValidator.TOO_MANY_START_JOINTS);
        }
      };
      startJoints.forEach(_function_1);
    }
  }
  
  public final static String NEW_OUTSIDE_REPEAT = "newOutsideRepeat";
  
  public final static String LAST_OUTSIDE_REPEAT = "lastOutsideRepeat";
  
  @Check
  public void checkUseOfNewAndLast(final BodyReference br) {
    boolean _or = false;
    boolean _isNew = br.isNew();
    if (_isNew) {
      _or = true;
    } else {
      boolean _and = false;
      boolean _isLast = br.isLast();
      if (!_isLast) {
        _and = false;
      } else {
        Body _ref = br.getRef();
        boolean _equals = Objects.equal(_ref, null);
        _and = _equals;
      }
      _or = _and;
    }
    if (_or) {
      EObject container = br;
      while (((!(container instanceof Model)) && (!(container instanceof BodyRepetition)))) {
        EObject _eContainer = container.eContainer();
        container = _eContainer;
      }
      if ((container instanceof Model)) {
        boolean _isNew_1 = br.isNew();
        if (_isNew_1) {
          this.error("new is only a valid body reference within a repeat expression.", br, 
            RigidBodiesPackage.Literals.BODY_REFERENCE__NEW, 
            ValidationMessageAcceptor.INSIGNIFICANT_INDEX, RigidBodiesValidator.NEW_OUTSIDE_REPEAT);
        } else {
          this.error("last must provide a body reference outside a repeat expression.", br, 
            RigidBodiesPackage.Literals.BODY_REFERENCE__LAST, 
            ValidationMessageAcceptor.INSIGNIFICANT_INDEX, RigidBodiesValidator.LAST_OUTSIDE_REPEAT);
        }
      }
    }
  }
  
  public final static String NO_NEW_IN_REPEAT = "noNewInRepeat";
  
  @Check
  public void repeatBodyMustContainJointDefinition(final BodyRepetition br) {
    EList<SystemElement> _connectionExp = br.getConnectionExp();
    Iterable<Joint> _filter = Iterables.<Joint>filter(_connectionExp, Joint.class);
    final Function1<Joint, Boolean> _function = new Function1<Joint, Boolean>() {
      @Override
      public Boolean apply(final Joint j) {
        boolean _or = false;
        BodyReference _body1 = j.getBody1();
        boolean _isNew = _body1.isNew();
        if (_isNew) {
          _or = true;
        } else {
          BodyReference _body2 = j.getBody2();
          boolean _isNew_1 = _body2.isNew();
          _or = _isNew_1;
        }
        return Boolean.valueOf(_or);
      }
    };
    boolean _exists = IterableExtensions.<Joint>exists(_filter, _function);
    boolean _not = (!_exists);
    if (_not) {
      this.error("Repeat expression must contain at least one joint referencing the new body.", br, 
        RigidBodiesPackage.Literals.BODY_REPETITION__CONNECTION_EXP, 
        ValidationMessageAcceptor.INSIGNIFICANT_INDEX, RigidBodiesValidator.NO_NEW_IN_REPEAT);
    }
  }
}
