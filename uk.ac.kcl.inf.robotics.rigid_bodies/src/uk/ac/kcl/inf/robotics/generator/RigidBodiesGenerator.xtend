/*
 * generated by Xtext
 */
package uk.ac.kcl.inf.robotics.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import uk.ac.kcl.inf.robotics.rigidBodies.AddExp
import uk.ac.kcl.inf.robotics.rigidBodies.BaseMatrix
import uk.ac.kcl.inf.robotics.rigidBodies.ConstantOrFunctionCallExp
import uk.ac.kcl.inf.robotics.rigidBodies.Environment
import uk.ac.kcl.inf.robotics.rigidBodies.MatrixRef
import uk.ac.kcl.inf.robotics.rigidBodies.Model
import uk.ac.kcl.inf.robotics.rigidBodies.MultExp
import uk.ac.kcl.inf.robotics.rigidBodies.NumberLiteral
import uk.ac.kcl.inf.robotics.rigidBodies.ParenthesisedExp
import uk.ac.kcl.inf.robotics.rigidBodies.System

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RigidBodiesGenerator implements IGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val model = resource.allContents.filter(Model).head
		resource.allContents.filter(System).forEach [ s |
			fsa.generateFile ('''«s.name».m''', generate (model.world, new ConnectiveTreeBuilder (s)))
		]
	}
	
	def generate(Environment world, 
		         ConnectiveTreeBuilder ctb) '''
		% EOM Simulation:
		clc
		clear all
		close all
		
		% Gravity vector
		g = [«world.gravity.renderValues (', ')»]
		
		% Inputs

		% Locations
		lc = [
			«(0..<ctb.positions.size).join (';\n', [ i | '''
					% Position data from «ctb.positions.get(i).key» for a joint «ctb.lcCodeColumns.get(i).value.key»
					«ctb.positions.get(i).value.renderValues (' ')» «ctb.lcCodeColumns.get(i).key» «ctb.lcCodeColumns.get(i).value.value»'''])»
			«(0..<ctb.constraintPositions.size).join (';\n', [ i | '''
					% Position data from «ctb.constraintPositions.get(i).key» for a constraint «ctb.constraintLcCodeColumns.get(i).value.key»
					% TODO: Check with Hadi that we're using the correct position data here.
					«ctb.constraintPositions.get(i).value.renderValues (' ')» «ctb.constraintLcCodeColumns.get(i).key» «ctb.constraintLcCodeColumns.get(i).value.value»'''])»
			«(0..<ctb.loadPositions.size).join (';\n', [ i | '''
					% Position data from «ctb.loadPositions.get(i).key» for a load «ctb.loadLcCodeColumns.get(i).value.key»
					«ctb.loadPositions.get(i).value.renderValues (' ')» «ctb.loadLcCodeColumns.get(i).key» «ctb.loadLcCodeColumns.get(i).value.value»'''])»
		];

		% Mass values
		m = [
			« // Generate masses vector
				ctb.masses.join (',\n', [m | '''
					% «m.key»
					«m.value.render»'''])»];
		
		% Inertia values
		I = sym (zeros (3, 3, «ctb.inertias.size»));
		«(0..<ctb.inertias.size).join ('\n', [idx | '''
				% Inertia for body «ctb.inertias.get(idx).key»
				I (:, :, «idx») = [
					«ctb.inertias.get(idx).value.renderValues (3)»];
			'''])»
		
		% Run program -- Should this really be generated?
		
		% EOM:
		[ M , T , Dd , fg , fj , rj , rc , vc , wc , ref , rcn ,  Tef , Tcn , Dcn , qf , uf ] = ...
			TMTEoM ( lc , m , I , j , jkd , g );
		
		% numerical simulation
		[ t , z , tfinal ] = SimEoM ( M , T , Dd , fg , fj , qf , uf , 1 );
		plot ( t , z );
		pause;
		
		% animation
		AnimEOM ( t , z , rj , qf , uf );
	'''
	
	def dispatch CharSequence renderValues(MatrixRef mr, CharSequence sep) {
		mr.matrix.renderValues (sep)
	}
	
	def dispatch CharSequence renderValues(BaseMatrix bm, CharSequence sep) {
		bm.values.join(sep, [v|v.render])
	}
	
	def dispatch CharSequence renderValues (BaseMatrix bm, int rowLength) {
		(0..<bm.values.size / rowLength).join (';\n', [y | 
				(0..<rowLength).join (' ', [ x | bm.values.get(y * rowLength + x).render ])
			])
	}

	def dispatch CharSequence render(AddExp e) {
		'''«e.left.render» «(0..<e.op.size).join (' ', [idx | '''«e.op.get (idx)» «e.right.get(idx).render»'''])»'''
	}

	def dispatch CharSequence render(
		MultExp e
	) '''«e.left.render» «(0..<e.op.size).join (' ', [idx | '''«e.op.get (idx)» «e.right.get(idx).render»'''])»'''

	def dispatch CharSequence render(ParenthesisedExp pe) '''(«pe.exp.render»)'''

	def dispatch CharSequence render(NumberLiteral literal) '''«if (literal.isNeg) {'''-'''}»«literal.value»'''

	def dispatch CharSequence render(
		ConstantOrFunctionCallExp cofce
	) '''«cofce.label» «if (cofce.param.size > 0) {'''(«cofce.param.join (', ', [p | p.render])»)'''}»'''
}
